-- --AppUser
-- CREATE TABLE AppUser ( 
--                     userID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--                     accountName VARCHAR2(50) UNIQUE NOT NULL,
--                     password VARCHAR2(255) NOT NULL);
                    
                    
-- --BillReminder                    
-- CREATE TABLE BillReminder ( 
--                             remindID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--                             remindName VARCHAR2(100) NOT NULL UNIQUE,
--                             deadline DATE NOT NULL,
--                             status VARCHAR2(30) DEFAULT 'Pending',
--                             userID NUMBER NOT NULL,
--                             CONSTRAINT fk_BillReminder FOREIGN KEY (userID) REFERENCES
--                             AppUser (userID));    
                            

-- --BillReminderHistory                            
-- CREATE TABLE BillReminderHistory (
--                                     historyID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--                                     remindID NUMBER NOT NULL,
--                                     remindName VARCHAR2(100) NOT NULL,
--                                     deadline DATE NOT NULL,
--                                     status VARCHAR2(30) NOT NULL,
--                                     userID NUMBER NOT NULL,
--                                     CONSTRAINT fk_BillReminderHistory FOREIGN KEY (userID) REFERENCES
--                                     AppUser (userID));
       
                                    
                                    
-- --Account                                    
-- CREATE TABLE Account (
--                         accID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--                         accName VARCHAR2(100) NOT NULL,
--                         description VARCHAR2(100),
--                         balance NUMBER(12, 2) NOT NULL,
--                         createdDate DATE DEFAULT SYSDATE,
--                         status VARCHAR2(15) DEFAULT 'Active',
--                         initialAmount NUMBER(12, 2) NOT NULL CHECK(initialAmount >=0 ),
--                         userID NUMBER NOT NULL,
--                         CONSTRAINT fk_Account FOREIGN KEY (userID) REFERENCES
--                         AppUser (userID));
                        
                        

-- --ExpenseAccount
-- CREATE TABLE ExpenseAccount (
--                             accID NUMBER PRIMARY KEY,
--                             expenseCategory VARCHAR2(30) NOT NULL CHECK(expenseCategory IN ('Entertainment', 'BillPayment', 'DailyExpense')),
--                             spendingLimit NUMBER DEFAULT 0 NOT NULL CHECK(spendingLimit >= 0),
--                             CONSTRAINT fk_ExpenseAccount FOREIGN KEY (accID) REFERENCES Account(accID));
                            

-- --FundAccount
-- CREATE TABLE FundAccount (
--                         accID NUMBER PRIMARY KEY,
--                         fundType VARCHAR2(30) NOT NULL CHECK(fundType IN ('LongTermSaving', 'EmergencyFund')),
--                         minimumLimit NUMBER DEFAULT 0 NOT NULL CHECK(minimumLimit >=0),
--                         CONSTRAINT fk_FundAccount FOREIGN KEY (accID) REFERENCES Account(accID));
                   
-- --SavingGoal
-- CREATE TABLE SavingGoal (
--                         goalID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--                         goalName VARCHAR2(50) NOT NULL,
--                         targetAmount NUMBER NOT NULL CHECK(targetAmount > 0),
--                         createdDate DATE DEFAULT SYSDATE,
--                         deadline DATE NOT NULL,
--                         accID NUMBER NOT NULL,
--                         CONSTRAINT chk_deadline CHECK (deadline > createdDate),
--                         CONSTRAINT fk_SavingGoals FOREIGN KEY (accID) REFERENCES Account(accID));
                        
-- --Transaction
-- CREATE TABLE AccountTransaction (
--                         transID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--                         transName VARCHAR2(50) NOT NULL,
--                         transType VARCHAR2(30)NOT NULL CHECK(transType IN ('Expense', 'Deposit')),
--                         transDate DATE DEFAULT SYSDATE,
--                         amount NUMBER(12,4) NOT NULL CHECK(amount > 0),
--                         accID NUMBER NOT NULL ,
--                         CONSTRAINT fk_Transaction FOREIGN KEY (accID) REFERENCES Account(accID));
                        


-- drop table AppUser;


--System

-- PASSWORD HASH TRIGGER
CREATE OR REPLACE TRIGGER passwordHashTrigger
BEFORE INSERT OR UPDATE OF password ON AppUser
FOR EACH ROW
BEGIN
    IF LENGTH(:NEW.password) != 64 THEN 
        SELECT STANDARD_HASH(:NEW.password, 'SHA256')
        INTO :NEW.password
        FROM dual;
    END IF;
END;
/



-- CREATE USER PROCEDURE
CREATE OR REPLACE PROCEDURE createUser(
        p_accountName IN VARCHAR2,
        p_password IN VARCHAR2,
        p_result OUT VARCHAR2
        )
IS
BEGIN
    INSERT INTO AppUser(accountName, password)
    VALUES (p_accountName, p_password);
    
    p_result := 'Successfully Created The Account';
    
EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN 
    p_result := 'This Username Is Already Exist';
END;
/


-- USER LOGIN PROCEDURE
CREATE OR REPLACE PROCEDURE userLogin(
        p_accountName IN VARCHAR2,
        p_password IN VARCHAR2,
        p_result OUT VARCHAR2
        )
IS
    v_password VARCHAR2(255);
    v_hashPassword VARCHAR2(255);
BEGIN
    SELECT password INTO v_password
    FROM AppUser
    WHERE accountName = p_accountName;
    
    SELECT STANDARD_HASH(p_password, 'SHA256') INTO v_hashPassword
    FROM dual;
    
    IF v_password = v_hashPassword THEN
        p_result := 'LOGIN SUCCESS';
    ELSE 
        p_result := 'INVALID PASSWORD';
    END IF;
EXCEPTION 
    WHEN NO_DATA_FOUND THEN 
        p_result := 'USERNAME NOT FOUND';
END;
/

-- UPDATE USER ACCOUNT PROCEDURE
CREATE OR REPLACE PROCEDURE userAccountUpdate(
        p_accountName IN VARCHAR2,
        p_password IN VARCHAR2,
        p_userID IN NUMBER,
        p_result OUT VARCHAR2
        )
IS
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count 
    FROM AppUser 
    WHERE userID = p_userID;
    
    IF v_count = 0 THEN
       p_result := 'USER NOT FOUND';
       RETURN;
    END IF;

    UPDATE AppUser 
    SET accountName = p_accountName,
        password = p_password
    WHERE userID = p_userID;

    p_result := 'ACCOUNT SUCCESSFULLY UPDATED'; 
    
EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN 
    p_result := 'This Username Is Already Exist';
END;
/

-- DELETE USER ACCOUNT PROCEDURE
CREATE OR REPLACE PROCEDURE userAccountDelete(
        p_userID IN NUMBER,
        p_result OUT VARCHAR2
        )
IS
BEGIN
    DELETE FROM AppUser
    WHERE userID = p_userID;
    
    IF SQL%ROWCOUNT = 0 THEN
       p_result := 'USER NOT FLUND';
    ELSE 
        p_result := 'ACCOUNT SUCCESSFULLY DELETED';
    END IF;
END;
/

-- VIEW USER ACCOUNT PROCEDURE
CREATE OR REPLACE FUNCTION userAccountView(
            p_userID IN NUMBER
            )
RETURN SYS_REFCURSOR
IS
    v_cursor SYS_REFCURSOR;
BEGIN
    OPEN v_cursor FOR
        SELECT accountName
        FROM AppUser
        WHERE userID = p_userID;
        
        RETURN v_cursor;
END; 
/       


-- create account
CREATE OR REPLACE PROCEDURE createAccount(
        p_accName IN VARCHAR2,
        p_description IN VARCHAR2,
        p_initialAmount IN NUMBER,
        p_userID IN NUMBER,
        p_accountType IN VARCHAR2,
        p_category IN VARCHAR2,
        p_limit IN NUMBER
        ) 
AS
    v_accID NUMBER;
BEGIN
    INSERT INTO Account (accName, description, balance, initialAmount, userID)
    VALUES (p_accName, p_description, p_initialAmount, p_initialAmount, p_userID)
    RETURNING accID INTO v_accID;
    
    IF p_accountType = 'Expense' THEN
    INSERT INTO ExpenseAccount (accID, expenseCategory, spendingLimit)
    VALUES (v_accID, p_category, p_limit);
    
    ELSE IF p_accountType = 'Fund' THEN
    INSERT INTO FundAccount(accID, fundType, minimumLimit)
    VALUES (v_accID, p_category, p_limit);
    
    END IF;
    END IF;

END;
/

-- VIEW ANY ACCOUNT USING DROPDOWN
CREATE OR REPLACE FUNCTION viewAccounts(
                p_category IN VARCHAR2,
                p_userID IN NUMBER) 
RETURN SYS_REFCURSOR
IS 
    v_cursor SYS_REFCURSOR;
BEGIN 
    IF p_category IN ('Entertainment', 'BillPayment', 'DailyExpense') THEN
    OPEN v_cursor FOR
        SELECT
            a.accName,
            a.description,
            a.balance,
            a.createdDate,
            a.status,
            a.initialAmount,
            e.spendingLimit
            FROM Account a 
            JOIN ExpenseAccount e ON a.accID = e.accID 
            WHERE e.expenseCategory = p_category 
            AND a.userID = p_userID;
            
    ELSE IF p_category IN ('LongTermSaving', 'EmergencyFund') THEN
    OPEN v_cursor FOR
        SELECT
            a.accName,
            a.description,
            a.balance,
            a.createdDate,
            a.status,
            a.initialAmount,
            f.minimumLimit
            FROM Account a 
            JOIN FundAccount f ON a.accID = f.accID 
            WHERE f.fundType = p_category 
            AND a.userID = p_userID;
            
            END IF;
            END IF;
            
            RETURN v_cursor;
END;
/

-- UPDATE ACCOUNT
CREATE OR REPLACE PROCEDURE updateAccount(
            p_accName IN VARCHAR2,
            p_description IN VARCHAR2,
            p_limit IN NUMBER,
            p_category IN VARCHAR2,
            p_accID IN NUMBER)
AS
BEGIN 
    UPDATE Account 
    SET accName = p_accName,
        description = p_description
    WHERE accID = p_accID;
    
    IF p_category IN ('Entertainment', 'BillPayment', 'DailyExpense') THEN
    UPDATE ExpenseAccount 
    SET spendingLimit = p_limit
    WHERE accID = p_accID;
    
    ELSE IF p_category IN ('LongTermSaving', 'EmergencyFund') THEN
    UPDATE FundAccount
    SET minimumLimit = p_limit
    WHERE accID = p_accID;
    
    END IF;
    END IF;
    
END;
/

-- DELETE ACCOUNT
CREATE OR REPLACE PROCEDURE deleteAccount(
                p_category IN VARCHAR2,
                p_accID IN NUMBER)
AS
BEGIN
    IF p_category IN ('Entertainment', 'BillPayment', 'DailyExpense') THEN
    DELETE FROM ExpenseAccount
    WHERE accID = p_accID;
    
    ELSE IF p_category IN ('LongTermSaving', 'EmergencyFund') THEN
    DELETE FROM FundAccount
    WHERE accID = p_accID;
    
    END IF; 
    END IF;
    
    DELETE FROM Account
    WHERE accID = p_accID;
END;
/

--Add Transaction
CREATE OR REPLACE PROCEDURE addTransaction(v_transName IN VARCHAR2, v_transType IN VARCHAR2, v_amount IN NUMBER, v_accID IN NUMBER) IS
v_fundAccount NUMBER;
v_expenseAccount NUMBER;
v_balance NUMBER;
v_spendingLimit NUMBER;
v_minimumLimit NUMBER;
BEGIN
    --check amount exceed the spending limit.
    SELECT COUNT(*) INTO v_expenseAccount FROM ExpenseAccount WHERE accID = v_accID;
    IF v_expenseAccount > 0 THEN
        SELECT spendingLimit INTO v_spendingLimit FROM ExpenseAccount WHERE accID = v_accID;
        SELECT balance INTO v_balance FROM Account WHERE accID = v_accID;
    
    IF v_transType = 'Expense' THEN 
        IF v_balance - v_amount < v_spendingLimit THEN 
            RAISE_APPLICATION_ERROR(-20001, 'Transaction exceed the spending limit');
        END IF;
    END IF;
    END IF;
    
    --check amount exceed the minimun limit.
    SELECT COUNT(*) INTO v_fundAccount FROM FundAccount WHERE accID = v_accID;
    IF v_fundAccount > 0 THEN 
        SELECT minimumLimit INTO v_minimumLimit FROM FundAccount WHERE accID = v_accID;
        SELECT balance INTO v_balance FROM ACCOUNT WHERE accID = v_accID;
    
    IF v_transType = 'Expense' THEN 
        IF v_balance - v_amount < v_minimumLimit THEN 
            RAISE_APPLICATION_ERROR(-20002, 'Transaction exceed the minimum limit');
        END IF;
    END IF;
    END IF;
            
    INSERT INTO AccountTransaction (transName, transType, amount, accID) VALUES (v_transName, v_transType, v_amount, v_accID);
END;
/

--Trigger to Update the balance in Account  and check bill reminder and add data to billReminderHistory
CREATE OR REPLACE TRIGGER updateBalance 
AFTER INSERT ON AccountTransaction 
FOR EACH ROW
DECLARE
    v_count NUMBER;
    v_billDetails BillReminder%ROWTYPE;
BEGIN
    IF :NEW.transTYPE = 'Expense' THEN 
    UPDATE ACCOUNT SET balance = balance - :NEW.amount WHERE accID = :NEW.accID;
    ELSE 
    UPDATE ACCOUNT SET balance = balance + :NEW.amount WHERE accID = :NEW.accID;
    END IF;
    
    --Delete the bill reminder and add to history
    SELECT COUNT(*) INTO v_count FROM BillReminder WHERE remindName = :NEW.transName;
    IF v_count > 0 THEN
        SELECT * INTO v_billDetails FROM BillReminder WHERE remindName = :NEW.transName;
        INSERT INTO BillReminderHistory (remindID, remindName, deadline, status, userID) VALUES (v_billDetails.remindID, v_billDetails.remindName, v_billDetails.deadline, 'Paid', v_billDetails.userID );
        DELETE FROM BillReminder WHERE remindID = v_billDetails.remindID;
    END IF;
END;
/




--View Transactions
CREATE OR REPLACE FUNCTION viewTransaction(v_accID NUMBER)
RETURN SYS_REFCURSOR
IS 
details SYS_REFCURSOR;
BEGIN
    OPEN details FOR 
    SELECT * FROM AccountTransaction WHERE accID = v_accID;
    RETURN details;
END;
/


--Edit Transaction
CREATE OR REPLACE PROCEDURE editTransaction(v_transID IN NUMBER, v_transName IN VARCHAR2, v_transType IN VARCHAR2, v_amount IN NUMBER) IS
BEGIN
    UPDATE AccountTransaction SET transName = v_transName, transType = v_transType, amount =  v_amount WHERE transID = v_transID;
END;
/

--Trigger to update the balance in Account;
CREATE OR REPLACE TRIGGER trig_updateBalance_whenEditingTransaction 
AFTER UPDATE ON AccountTransaction
FOR EACH ROW
BEGIN
    IF :OLD.transType = 'Deposit' AND :NEW.transType = 'Expense' THEN
    UPDATE Account SET balance = balance - (:OLD.amount + :NEW.amount) WHERE accID = :OLD.accID;
    
    ELSIF :OLD.transType = 'Expense' AND :NEW.transType = 'Deposit' THEN 
    UPDATE Account SET balance = balance + (:OLD.amount + :NEW.amount) WHERE accID = :OLD.accID;
    
    ELSIF :OLD.transType = 'Deposit' AND :NEW.transType = 'Deposit' THEN 
    UPDATE Account SET balance = balance - :OLD.amount + :NEW.amount WHERE accID = :OLD.accID;
    
    ELSIF :OLD.transType = 'Expense' AND :NEW.transType = 'Expense' THEN 
    UPDATE Account SET balance = balance + :OLD.amount - :NEW.amount WHERE accID = :OLD.accID;
    
    END IF;
END;
/



--Delete Transaction
CREATE OR REPLACE PROCEDURE deleteTransaction(v_transID IN NUMBER) IS 
BEGIN
    DELETE FROM AccountTransaction WHERE transID = v_transID;
END;
/

--Trigger to update the balance after delete a transaction;
CREATE OR REPLACE TRIGGER trig_updateBalance_afterDeletingTransaction 
AFTER DELETE ON AccountTransaction
FOR EACH ROW
BEGIN
    IF :OLD.transType = 'Deposit' THEN
    UPDATE ACCOUNT SET balance = balance - :OLD.amount WHERE accID = :OLD.accID;
    ELSE 
    UPDATE ACCOUNT SET balance = balance + :OLD.amount WHERE accID = :OLD.accID;
    END IF;
END;
/



--addBillReminder
CREATE OR REPLACE PROCEDURE addBillReminer(v_remindName IN VARCHAR2, v_deadline IN DATE, v_userID IN NUMBER) IS 
BEGIN
    INSERT INTO billReminder (remindName, deadline, userID) VALUES (v_remindName, v_deadline, v_userID);
END;
/


--View Bill reminder 
CREATE OR REPLACE FUNCTION viewBillReminder(v_userID NUMBER)
RETURN SYS_REFCURSOR
IS
cur SYS_REFCURSOR;
BEGIN
    OPEN cur FOR
    SELECT remindName, deadLine, status FROM BillReminder WHERE userID = v_userID;
    RETURN cur;
END;
/

--View bill reminders with 3 days before deadiline
CREATE OR REPLACE FUNCTION getUpcomingBillReminders(v_userID NUMBER) 
RETURN SYS_REFCURSOR
IS
cur SYS_REFCURSOR;
BEGIN
    OPEN cur FOR SELECT remindName, deadline, status, 
    CASE
        WHEN TRUNC(deadline) = TRUNC(SYSDATE) THEN 'Due Today' 
        WHEN TRUNC(deadline) - TRUNC(SYSDATE) = 1 THEN 'Only 1 day'
        WHEN TRUNC(deadline) - TRUNC(SYSDATE) = 2 THEN 'Only 2 days'
        WHEN TRUNC(deadline) - TRUNC(SYSDATE) = 3 THEN 'Only 3 days'
        ELSE 'Not Urgent'
    END AS message 
    FROM BillReminder WHERE userID = v_userID AND TRUNC(deadline) - TRUNC(SYSDATE) <=3 AND TRUNC(deadline) >= TRUNC(SYSDATE) 
    ORDER BY deadline;
    RETURN cur;
END;
/


--Report Generation
--â€¢	Monthly expenditure analysis
CREATE OR REPLACE FUNCTION getMonthlyExpenditure(v_id NUMBER) 
RETURN SYS_REFCURSOR
IS
    cur SYS_REFCURSOR;
BEGIN
    OPEN cur FOR
        SELECT TO_CHAR(t.transDate, 'YYYY-MONTH') as month, SUM(t.amount) as totalExpenses, MAX(t.amount) as maxTransaction 
        FROM AccountTransaction t JOIN Account a ON a.accID = t.accID WHERE a.userID = v_id AND t.transType = 'Expense' 
        GROUP BY TO_CHAR(transDate, 'YYYY-MONTH') ORDER BY TO_CHAR(transType, 'YYYY-MONTH');
        RETURN cur;
END;
/

--Saving goal progress
CREATE OR REPLACE FUNCTION getSavingGoals(v_userID NUMBER)
RETURN SYS_REFCURSOR
IS
    cur SYS_REFCURSOR;
BEGIN
    OPEN cur FOR 
    SELECT g.goalName, g.targetAmount, a.balance, TRUNC(deadLine-SYSDATE) AS remainingDays, 
    CASE WHEN (a.balance/g.targetAmount)*100 >= 100 THEN 100
        ELSE (a.balance/g.targetAmount)*100
    END AS progressStatus, 
    CASE WHEN a.balance < g.targetAmount THEN 'Pending' 
        ELSE 'Achieved' 
    END AS status
    FROM SavingGoal g JOIN Account a ON g.accID = a.accID WHERE a.userID = v_userID;
    RETURN cur;
END;
/


-- CAREGORY-WISE EXPENSE DISTRIBUTION
CREATE OR REPLACE FUNCTION categoryWiseExpenseReport(
            p_userID IN NUMBER
            )
RETURN SYS_REFCURSOR
IS
    v_cursor SYS_REFCURSOR;
BEGIN
    OPEN v_cursor FOR 
        SELECT 
            a.accName AS Account_Name, 
            ea.expenseCategory AS Expense_Category,
            SUM(t.amount) AS Total_Amount
            FROM AccountTransaction t
            JOIN Account a ON t.accID = a.accID
            JOIN ExpenseAccount ea ON a.accID = ea.accID
            WHERE a.userID = p_userID 
            AND t.transType = 'Expense'
            GROUP BY ea.expenseCategory, a.accName
            ORDER BY SUM(t.amount) DESC;
        
        RETURN v_cursor;
END;
/

-- BUDGET ADHERENCE TRACKING
CREATE OR REPLACE FUNCTION budgetTrackingReport(
            p_userID IN NUMBER
            )
RETURN SYS_REFCURSOR
IS
    v_cursor SYS_REFCURSOR;
BEGIN
    OPEN v_cursor FOR 
        SELECT 
            a.accName AS Account_Name, 
            ea.expenseCategory AS Expense_Category,
            a.balance AS Current_Balance,
            ea.spendingLimit AS Spending_Limit,
            (a.balance - ea.spendingLimit) AS Remaining_Budget,
            CASE
                WHEN a.balance <= ea.spendingLimit THEN 'Spending Limit Reached'
                WHEN a.balance - ea.spendingLimit < (ea.spendingLimit * 0.25) THEN 'Near To Spending Limit'
                ELSE 'Within Spending Limit'
            END AS Status
        FROM Account a
        JOIN ExpenseAccount ea ON a.accID = ea.accID
        WHERE a.userID = p_userID
        ORDER BY (a.balance - ea.spendingLimit) ASC;
    RETURN v_cursor;
END;

/

--Forecast saving trend
CREATE OR REPLACE FUNCTION getForcastedSaving(v_userID NUMBER) 
RETURN SYS_REFCURSOR
IS
    cur SYS_REFCURSOR;
BEGIN
    OPEN cur FOR 
    SELECT month, net_saving, ROUND(AVG(net_saving) OVER (), 2) AS forecast_next
    FROM(SELECT TO_CHAR(TRUNC(t.transDate, 'MM'), 'YYYY--MM') AS month,
        SUM(CASE 
            WHEN t.transType = 'Deposit' THEN t.amount
            WHEN t.transType = 'Expense' THEN -t.amount
            ELSE 0
            END) AS net_saving
    FROM AccountTransaction t JOIN Account a ON a.accID = t.accID WHERE a.userID = v_userID
    GROUP BY TRUNC(t.transDate, 'MM')
    )
    ORDER BY month;
    RETURN cur;

    
END;
/


-- nethmi
-- 1. PL/SQL Procedure: CreateSavingsGoal
-- Allowing users to set a savings goal with a target amount and a deadline.

CREATE OR REPLACE PROCEDURE CreateSavingsGoal (
    p_goalID        IN NUMBER,
    p_accID         IN NUMBER,
    p_goalName      IN VARCHAR2,
    p_targetAmount  IN NUMBER,
    p_deadline      IN DATE
) IS
BEGIN
    INSERT INTO SavingGoal (goalID, goalName, targetAmount, createdDate, deadline, accID)
    VALUES (p_goalID, p_goalName, p_targetAmount, SYSDATE, p_deadline, p_accID);

    DBMS_OUTPUT.PUT_LINE('Savings goal "' || p_goalName || '" created with target of ' || p_targetAmount);
END;
/

-- 2. PL/SQL Block: ShowGoalProgress
-- The system shall visually track the progress towards the goal (e.g., 60% complete).â€

CREATE OR REPLACE FUNCTION ShowGoalProgress
RETURN SYS_REFCURSOR
IS
    v_cursor SYS_REFCURSOR;
BEGIN
    OPEN v_cursor FOR
        SELECT g.goalName,
               g.targetAmount,
               g.deadline,
               NVL(SUM(t.amount), 0) AS currentAmount,
               CASE
                WHEN g.targetAmount > 0 THEN
                ROUND((NVL(SUM(t.amount), 0) / g.targetAmount) * 100, 2)
                ELSE 0
               END AS progressPercentage 
        FROM SavingGoal g
        LEFT JOIN AccountTransaction t
            ON g.accID = t.accID
           AND t.transType = 'Deposit'
        GROUP BY g.goalName, g.targetAmount, g.deadline;
        
        RETURN v_cursor;
END;
/

-- 3. Trigger: trg_goal_completed
-- Automatically mark a goal as completed when it reaches 100%.

CREATE OR REPLACE TRIGGER trg_goal_completed
AFTER INSERT OR UPDATE OF amount ON AccountTransaction
FOR EACH ROW
DECLARE
    v_goalName SavingGoal.goalName%TYPE;
    v_targetAmount SavingGoal.targetAmount%TYPE;
    v_total NUMBER;
BEGIN
    SELECT g.goalName, g.targetAmount
    INTO v_goalName, v_targetAmount
    FROM SavingGoal g
    WHERE g.accID = :NEW.accID;

    SELECT NVL(SUM(t.amount), 0)
    INTO v_total
    FROM AccountTransaction t
    WHERE t.accID = :NEW.accID
      AND t.transType = 'Deposit';

    IF v_total >= v_targetAmount THEN
        DBMS_OUTPUT.PUT_LINE('ðŸŽ‰ Goal "' || v_goalName || '" has been reached! Total Saved: ' || v_total);
    END IF;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        NULL; 
END;
/



